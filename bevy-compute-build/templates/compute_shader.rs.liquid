use bevy::{
    prelude::*,
    render::{
        render_resource::{BindGroupLayout, CachedComputePipelineId, ComputePipelineDescriptor, PipelineCache},
        renderer::RenderDevice, RenderApp,
    },
    utils::HashMap,
};

{% capture compute_pipeline_name %}{{ shader_name | upper_camel_case }}ComputePipeline{% endcapture %}
{% capture plugin_name %}{{ shader_name | upper_camel_case }}Plugin{% endcapture %}

struct {{ plugin_name }};

impl Plugin for {{ plugin_name }} {
    fn build(&self, _app: &mut App) {}
    fn finish(&self, app: &mut App) {
        let render_app = app.sub_app_mut(RenderApp);
        render_app
            .init_resource::<{{ compute_pipeline_name }}>();
    }
}

#[derive(Resource)]
struct {{ compute_pipeline_name }} {
    layout: BindGroupLayout,
    pipelines: HashMap<&'static str, CachedComputePipelineId>,
}

impl FromWorld for {{ compute_pipeline_name }} {
    fn from_world(world: &mut World) -> Self {
        let render_device = world.resource::<RenderDevice>();
        let layout = FooBuffers::layout(render_device);
        let shader = world.load_asset("{{ shader_path }}");
        let pipeline_cache = world.resource::<PipelineCache>();

        let pipelines = HashMap::from([
            {% for entry in entries %}
            (
                "{{ entry }}",
                pipeline_cache.queue_compute_pipeline(ComputePipelineDescriptor {
                    label: Some("{{ shader_name }} :: {{ entry }}".into()),
                    layout: vec![layout.clone()],
                    push_constant_ranges: Vec::new(),
                    shader,
                    shader_defs: Vec::new(),
                    entry_point: "{{ entry }}".into(),
                    zero_initialize_workgroup_memory: false,
                }),
            ),
            {% endfor %}
        ]);
        Self { layout, pipelines }
    }
}

// TODO;
struct FooBuffers;

impl FooBuffers {
    fn layout(device: &RenderDevice) -> BindGroupLayout {
        todo!()
    }
}


